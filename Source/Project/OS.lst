C51 COMPILER V9.00   OS                                                                    05/12/2015 20:18:27 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE OS
OBJECT MODULE PLACED IN .\mess\OS.obj
COMPILER INVOKED BY: D:\software install\NEW\keil 4\C51\BIN\C51.EXE ..\ZOS-I\source\src\OS.c BROWSE INCDIR(..\user;..\ZO
                    -S-I\source\inc;..\ZOS-I\source\CPU) DEBUG OBJECTEXTEND PRINT(.\OS.lst) OBJECT(.\mess\OS.obj)

line level    source

   1          /*$T indentinput.cpp GC 1.140 02/27/15 15:33:11 */
   2          
   3          
   4          /*$6
   5           +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
             -++++++++++++++
   6              ZJYC
   7           +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
             -++++++++++++++
   8           */
   9          
  10          
  11          #include <OS.h>
  12          
  13          OS_CPU_XUCHAR           OS_TaskReadyList[OS_MAX_NUM_TASK / 8 + 1] = { 0 };              /* 就续表 */
  14          OS_CPU_XUCHAR           OS_TaskRegGroup[OS_MAX_NUM_TASK][OS_REG_SIZE] = { 0 };  /* 任务寄存器组 */
  15          OS_CPU_XP_XUCHAR        OS_TaskStackAddr[OS_MAX_NUM_TASK] = { 0 };                              /* 任务堆栈地址 */
  16          OS_CPU_XUCHAR           OS_TaskCurLength[OS_MAX_NUM_TASK] = { 0 };                              /* 当前堆栈长度 */
  17          OS_CPU_XUCHAR           OS_TaskStackSize[OS_MAX_NUM_TASK] = { 0 };                              /* 任务堆栈总长度 */
  18          OS_CPU_XUINT            OS_TaskStatus[OS_MAX_NUM_TASK] = { 0 };                                 /* 任务状态 */
  19          OS_CPU_XUCHAR           OS_TaskTickList[OS_MAX_NUM_TASK / 8 + 1] = { 0 };               /* 滴答列表 */
  20          OS_CPU_XUINT            OS_TaskTickCounter[OS_MAX_NUM_TASK] = { 0 };                    /* 滴答计数器 */
  21          OS_CPU_UCHAR            OS_CurTaskNum = 0;                                              /* 当前任务 */
  22          OS_CPU_UCHAR            OS_NexTaskNum = 0;                                              /* 下一任务 */
  23          OS_CPU_UCHAR            OS_SPDefaultValue = 0;                                  /* 默认堆栈指针 */
  24          OS_CPU_UCHAR            TH0_Reload = 0;                                                 /* TH0 */
  25          OS_CPU_UCHAR            TL0_Reload = 0;                                                 /* TL0 */
  26          OS_CPU_UCHAR            OsMaxNumOfTask = OS_MAX_NUM_TASK;               /* 任务最大数 */
  27          OS_CPU_UCHAR            OsCpuCharSize = OS_CPU_UCHAR_LENGTH;    /* 字节大小 */
  28          OS_CPU_XUCHAR           Task_Idle_Stack[Task_Idle_StackSize] = { 0 };   /* 空闲任务堆栈 */
  29          OS_CPU_UCHAR            OS_RegSize = OS_REG_SIZE;                                               /* 寄存器组大小 */
  30          
  31          /* 统计工作 */
  32          #if OS_State_ENABLE
  33          OS_CPU_UINT                     CPU_Usage_Counter[OS_MAX_NUM_TASK] = { 0 };
  34          OS_CPU_UINT                     CPU_TickCounter_ALL = 0;
  35          #endif
  36          OS_CPU_XUINT            CPU_Usage_ALL = 0;                                      /* CPU使用率 */
  37          OS_CPU_XUINT            CPU_Usage[OS_MAX_NUM_TASK] = { 0 }; /* 各个任务的CPU使用率 */
  38          
  39          /* 定时器 */
  40          #if OS_TIMER_ENABLE
  41          OS_CPU_UINT                     OS_TIMER_Counter = 0;
  42          OS_CPU_UINT                     OS_TIMER_ARRAY[OS_TIMER_MAX_NUM] = { 0 };
  43          OS_X_TMR                        OS_X_Tmr = { 0 };
  44          #endif
  45          
  46          /* 操作系统任务 */
  47          OS_X_MSG                        OS_Msg_SYS = { 0 };
  48          OS_CPU_XUCHAR           Task_SYS_Stack[Task_SYS_StackSize] = { 0 };
  49          OS_CPU_XUCHAR           SYS_MSG_BUFF[Task_SYS_MsgLength] = { 0 };
  50          
  51          /* 时间戳使能 */
  52          #if OS_TIMESTAMP_ENABLE
C51 COMPILER V9.00   OS                                                                    05/12/2015 20:18:27 PAGE 2   

  53          OS_CPU_ULONG            Timestamp = 0;                                          /* 时间戳 */
  54          #endif
  55          
  56          /* 堆栈检查功能 */
  57          #if OS_STACKCHECK_ENABLE
  58          OS_CPU_UCHAR            OS_StackCheckCounter = 0;
  59          #endif
  60          
  61          /*
  62           =========================================================================================================
             -==============
  63              操作系统初始化
  64           =========================================================================================================
             -==============
  65           */
  66          void OS_Init(void)
  67          {
  68   1              /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
  69   1              OS_CPU_XUCHAR   ReadyListLength = sizeof(OS_TaskReadyList);
  70   1              OS_CPU_XUCHAR   i = 0;
  71   1              /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
  72   1      
  73   1              PreventWarning(0);                                              /* 防止编译器警告 */
  74   1      
  75   1              for(i = 0; i < ReadyListLength; i++)
  76   1              {
  77   2                      OS_TaskReadyList[i] = 0x00;                     /* 就续表清零 */
  78   2              }
  79   1      
  80   1              for(i = 0; i < OS_MAX_NUM_TASK; i++)
  81   1              {
  82   2                      OS_TaskStackAddr[i] = OS_CPU_NULL;      /* 堆栈地址清零 */
  83   2                      OS_TaskCurLength[i] = OS_CPU_NULL;      /* 堆栈长度清零 */
  84   2                      OS_TaskStatus[i] = OS_CPU_NULL;         /* 任务状态清零 */
  85   2              }
  86   1      
  87   1              /* 系统任务 */
  88   1              TaskCreate((OS_CPU_INT) OS_SYS_Task, Task_SYS_Stack, Task_SYS_StackSize, Task_SYS_Prio);
  89   1      
  90   1              /* 空闲任务 */
  91   1              TaskCreate((OS_CPU_INT) TaskIdle, Task_Idle_Stack, Task_Idle_StackSize, Task_Idle_Prio);
  92   1      
  93   1              OS_SPDefaultValue = SP - 2;                             /* 获取基准堆栈位置 */
  94   1              OS_SysTickInit();                                               /* 滴答初始化 */
  95   1      }
  96          
  97          /*
  98           =========================================================================================================
             -==============
  99              滴答任务（时间管理任务）
 100           =========================================================================================================
             -==============
 101           */
 102          void TickTask(void)
 103          {
 104   1              /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
 105   1              OS_CPU_UCHAR    i = 0, j = 0, Temp = 0, Temp_2 = 0;
 106   1              /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
 107   1      
 108   1      #if OS_State_ENABLE                                                     /* 统计单元 */
 109   1              CPU_TickCounter_ALL++;
 110   1              CPU_Usage_Counter[OS_CurTaskNum]++;
C51 COMPILER V9.00   OS                                                                    05/12/2015 20:18:27 PAGE 3   

 111   1              if(CPU_TickCounter_ALL >= OS_State_Period)
 112   1              {
 113   2                      CPU_TickCounter_ALL = 0;
 114   2                      SYS_MSG_BUFF[0] = 2;
 115   2                      OS_SendMessage_INT(&OS_Msg_SYS, &SYS_MSG_BUFF, 0);
 116   2              }
 117   1      #endif
 118   1      #if OS_TIMER_ENABLE                                                     /* 定时器单元 */
 119   1              OS_TIMER_Counter++;
 120   1              {
 121   2                      /*~~~~~~~~~~~~~~~~~~*/
 122   2                      OS_CPU_UCHAR    i = 0;
 123   2                      /*~~~~~~~~~~~~~~~~~~*/
 124   2      
 125   2                      for(i = 0; i < OS_TIMER_MAX_NUM; i++)
 126   2                      {
 127   3                              if(OS_TIMER_Counter == OS_TIMER_ARRAY[i])
 128   3                              {
 129   4                                      SYS_MSG_BUFF[1] = 1;
 130   4                                      OS_SendMessage_INT(&OS_Msg_SYS, &SYS_MSG_BUFF, 0);
 131   4                                      break;
 132   4                              }
 133   3                      }
 134   2              }
 135   1      #endif
 136   1      #if OS_TIMESTAMP_ENABLE                                         /* 时间戳单元 */
 137   1              Timestamp++;                                                    /* 时间戳 */
 138   1      #endif
 139   1      #if OS_HOOK_ENABLE                                                      /* 钩子函数 */
 140   1              TickTask_HOOK();
 141   1      #endif
 142   1      #if OS_STACKCHECK_ENABLE                                        /* 堆栈检查 */
 143   1              OS_StackCheckCounter++;
 144   1              if(OS_StackCheckCounter % 10 == 0)
 145   1              {
 146   2                      SYS_MSG_BUFF[2] = 3;
 147   2                      OS_SendMessage_INT(&OS_Msg_SYS, &SYS_MSG_BUFF, 0);
 148   2              }
 149   1      #endif
 150   1      #if true                                                                        /* 滴答任务主体 */
 151   1              for(i = 0; i < sizeof(OS_TaskTickList); i++)
 152   1              {
 153   2                      Temp = OS_TaskTickList[i];                      /* 获取等待列表 */
 154   2      
 155   2                      if(Temp != 0)
 156   2                      {
 157   3                              for(j = 0; j < OS_CPU_UCHAR_LENGTH; j++)
 158   3                              {
 159   4                                      if((Temp & (1 << j)))
 160   4                                      {
 161   5                                              Temp_2 = (i + 1) * j;   /* 获取等待任务序号 */
 162   5      
 163   5                                              if(OS_TaskTickCounter[Temp_2] == 0)
 164   5                                              {
 165   6                                                      /* 计数器减为零-》任务变为就绪 */
 166   6                                                      DISABLE_ALL_INT();
 167   6                                                      AddToReadyList(Temp_2);
 168   6                                                      DeleteFromTickList(Temp_2);
 169   6                                                      ENABLE_ALL_INT();
 170   6                                              }
 171   5                                              else
 172   5                                              {
C51 COMPILER V9.00   OS                                                                    05/12/2015 20:18:27 PAGE 4   

 173   6                                                      /* 计数器减一 */
 174   6                                                      OS_TaskTickCounter[Temp_2]--;
 175   6                                              }
 176   5                                      }
 177   4                              }
 178   3                      }
 179   2              }
 180   1      #endif
 181   1      }
 182          
 183          /*
 184           =========================================================================================================
             -==============
 185              非堵塞延时（Counter：延时滴答数）
 186           =========================================================================================================
             -==============
 187           */
 188          void OS_Delay_nTick(OS_CPU_UINT Counter)
 189          {
 190   1              if(Counter == 0) return;
 191   1              DISABLE_ALL_INT();
 192   1              DeleteFromReadyList(OS_CurTaskNum); /* 从就绪列表删除 */
 193   1              AddToTickList(OS_CurTaskNum);           /* 添加到等待列表 */
 194   1              OS_TaskTickCounter[OS_CurTaskNum] = Counter;    /* 装入时间长度 */
 195   1              OS_TaskSwitch();        /* 任务调度 */
 196   1              ENABLE_ALL_INT();
 197   1      }
 198          
 199          /*
 200           =========================================================================================================
             -==============
 201              启动系统
 202           =========================================================================================================
             -==============
 203           */
 204          void OS_Start(void)
 205          {
 206   1              /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
 207   1              OS_CPU_XUCHAR           ActivedTaskNum;
 208   1              OS_CPU_P_UCHAR          pTemp = (OS_CPU_P_UCHAR) 0x00 + OS_SPDefaultValue;
 209   1              OS_CPU_XP_XUCHAR        pTemp_2 = OS_TaskStackAddr[0];  /* 指向任务0 */
 210   1              /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
 211   1      
 212   1              /* 寻找已经激活的任务 */
 213   1              for(ActivedTaskNum = 0; ActivedTaskNum < OS_MAX_NUM_TASK; ActivedTaskNum++)
 214   1              {
 215   2                      if((OS_TaskStatus[ActivedTaskNum] & Task_Actived) != 0)
 216   2                      {
 217   3                              pTemp_2 = OS_TaskStackAddr[ActivedTaskNum];
 218   3      
 219   3                              break;
 220   3                      }
 221   2              }
 222   1      
 223   1              if(ActivedTaskNum == OS_MAX_NUM_TASK)                           /* 未找到激活任务，出错 */
 224   1              {
 225   2                      while(1) DISABLE_ALL_INT();
 226   2              }
 227   1      
 228   1              /* 指向优先级最高已激活任务 */
 229   1              pTemp++;
 230   1      
C51 COMPILER V9.00   OS                                                                    05/12/2015 20:18:27 PAGE 5   

 231   1              *pTemp = pTemp_2[0];
 232   1      
 233   1              pTemp++;
 234   1      
 235   1              *pTemp = pTemp_2[1];
 236   1      }
 237          
 238          /*
 239           =========================================================================================================
             -==============
 240              创建一个任务(TaskName:任务名称 Stack:任务堆栈地址
 241              StackSize:堆栈大小 TaskPrio: :任务优先级)
 242           =========================================================================================================
             -==============
 243           */
 244          void TaskCreate(OS_CPU_INT TaskName, OS_CPU_P_XUCHAR Stack, OS_CPU_UCHAR StackSize, OS_CPU_CHAR TaskPrio)
 245          {
 246   1      #if OS_HOOK_ENABLE
 247   1              TaskCreate_HOOK();      /* 调用钩子 */
 248   1      #endif
 249   1              if((OS_TaskStatus[TaskPrio] & Task_Actived) == 0)       /* 确保任务未被激活 */
 250   1              {
 251   2                      DISABLE_ALL_INT();
 252   2                      AddToReadyList(TaskPrio);                                               /* 任务变为就绪 */
 253   2                      OS_TaskStackAddr[TaskPrio] = Stack;                             /* 添加任务堆栈地址 */
 254   2                      OS_TaskStackSize[TaskPrio] = StackSize;                 /* 添加任务堆栈长度 */
 255   2                      OS_TaskStatus[TaskPrio] |= Task_Actived;                /* 任务已激活 */
 256   2                      Stack[1] = (TaskName & 0xff00) >> 8;                    /* 堆栈包含任务地址 */
 257   2                      Stack[0] = TaskName & 0x00ff;
 258   2                      OS_TaskCurLength[TaskPrio] = 2;                                 /* 堆栈长度为2字节 */
 259   2                      ENABLE_ALL_INT();
 260   2              }
 261   1              else
 262   1              {
 263   2                      while(1) DISABLE_ALL_INT();                                             /* 任务已经激活了 */
 264   2              }
 265   1      }
 266          
 267          /*
 268           =========================================================================================================
             -==============
 269              系统滴答初始化
 270           =========================================================================================================
             -==============
 271           */
 272          void OS_SysTickInit(void)
 273          {
 274   1              /*~~~~~~~~~~~~~~~~~~~~~~~*/
 275   1              OS_CPU_XUINT    Temp_1 = 0;
 276   1              OS_CPU_XUINT    Temp_2 = 0;
 277   1              /*~~~~~~~~~~~~~~~~~~~~~~~*/
 278   1      
 279   1              DISABLE_ALL_INT();
 280   1              Temp_1 = OS_CryFrequency / OS_CPU_Instruction_Cycle / 1000000L; /* 一微秒几个周期 */
 281   1              Temp_2 = 1000000L / OS_TickFrequency * Temp_1;                                  /* 滴答需要几个周期 */
 282   1              Temp_2 = 65536 - Temp_2;
 283   1              TH0_Reload = Temp_2 / 256;
 284   1              TL0_Reload = Temp_2 % 256;
 285   1              TMOD &= 0xF0;   /* 设置定时器模式 */
 286   1              TMOD |= 0x01;   /* 设置定时器模式 */
 287   1              TH0 = TH0_Reload;
 288   1              TL0 = TL0_Reload;
C51 COMPILER V9.00   OS                                                                    05/12/2015 20:18:27 PAGE 6   

 289   1              ET0 = 1;
 290   1              TR0 = 1;
 291   1              ENABLE_ALL_INT();
 292   1      }
 293          
 294          /*
 295           =========================================================================================================
             -==============
 296              手动任务切换函数
 297           =========================================================================================================
             -==============
 298           */
 299          void OS_TaskSwitchManual(void)
 300          {
 301   1              OS_TaskSwitch();        /* 任务切换 */
 302   1      }
 303          
 304          /*
 305           =========================================================================================================
             -==============
 306              发送信号（RecevNum：信号接收者优先级号）
 307           =========================================================================================================
             -==============
 308           */
 309          void OS_SendSignal(OS_CPU_UCHAR RecevNum)
 310          {
 311   1      #if OS_Signal_ENABLE
 312   1              if(RecevNum == OS_CurTaskNum) return;                           /* 向自己发送信号 */
 313   1              if(OS_TaskStatus[RecevNum] & Task_Hang_SIGNAL)          /* 确认任务是否在等 */
 314   1              {
 315   2                      DISABLE_ALL_INT();
 316   2                      OS_TaskStatus[RecevNum] &= ~Task_Hang_SIGNAL;   /* 清除等待状态 */
 317   2                      AddToReadyList(RecevNum);                                               /* 加入就续表 */
 318   2                      OS_TaskSwitch();        /* 任务切换 */
 319   2                      ENABLE_ALL_INT();
 320   2              }
 321   1      
 322   1      #else
                      RecevNum = RecevNum;
              #endif
 325   1      }
 326          
 327          /*
 328           =========================================================================================================
             -==============
 329              发送信号(ISR)(RecevNum:信号接收者优先级号)
 330           =========================================================================================================
             -==============
 331           */
 332          void OS_SendSignal_INT(OS_CPU_UCHAR RecevNum)
 333          {
 334   1      #if OS_Signal_ENABLE
 335   1              if(OS_TaskStatus[RecevNum] & Task_Hang_SIGNAL)          /* 确认任务是否在等 */
 336   1              {
 337   2                      DISABLE_ALL_INT();
 338   2                      OS_TaskStatus[RecevNum] &= ~Task_Hang_SIGNAL;   /* 清除等待状态 */
 339   2                      AddToReadyList(RecevNum);                                               /* 加入就续表 */
 340   2                      ENABLE_ALL_INT();
 341   2              }
 342   1      
 343   1      #else
                      RecevNum = RecevNum;
C51 COMPILER V9.00   OS                                                                    05/12/2015 20:18:27 PAGE 7   

              #endif
 346   1      }
 347          
 348          /*
 349           =========================================================================================================
             -==============
 350              等待信号
 351           =========================================================================================================
             -==============
 352           */
 353          void OS_PendSignal(void)
 354          {
 355   1      #if OS_Signal_ENABLE
 356   1              DISABLE_ALL_INT();
 357   1              OS_TaskStatus[OS_CurTaskNum] |= Task_Hang_SIGNAL;       /* 状态等待SIGNAL */
 358   1              DeleteFromReadyList(OS_CurTaskNum);                                     /* 删除就续表 */
 359   1              OS_TaskSwitch();                                                /* 任务切换 */
 360   1              ENABLE_ALL_INT();
 361   1      #else
              #endif
 363   1      }
 364          
 365          /*
 366           * 等待消息。参数：Message（消息结构体地址）Size（消息大小）
 367           */
 368          void OS_PendMessage (OS_MSG * Message) reentrant
 369          {
 370   1      #if OS_Message_ENABLE
 371   1              OS_MSG  *Temp = Message;
 372   1              DISABLE_ALL_INT();
 373   1              Message->PendTaskNum = OS_CurTaskNum;   /* 记录消息等待者 */
 374   1              DeleteFromReadyList(OS_CurTaskNum);             /* 删除就续表 */
 375   1              OS_TaskStatus[OS_CurTaskNum] |= Task_Hang_MEAASGE;      /* 状态等待MESSAGE */
 376   1              OS_TaskSwitch();        /* 任务切换 */
 377   1              ENABLE_ALL_INT();
 378   1              Message = Temp;         /* ？？ */
 379   1              return;                         /* 返回消息指针 */
 380   1      #else
                      Message = Message;
                      return;
              #endif
 384   1      }
 385          
 386          /*
 387           * 发送消息。Message（消息结构体地址）Size（消息大小）
 388           * MsgAddr（消息地址）
 389           */
 390          void OS_SendMessage (OS_MSG * Message, OS_CPU_XP_VOID MsgAddr, OS_CPU_CHAR Size) reentrant
 391          {
 392   1      #if OS_Message_ENABLE
 393   1              if(OS_TaskStatus[Message->PendTaskNum] & Task_Hang_MEAASGE)             /* 确定是否在等 */
 394   1              {
 395   2                      /* 等待者就续 */
 396   2                      AddToReadyList(Message->PendTaskNum);
 397   2                      OS_TaskStatus[Message->PendTaskNum] &= ~Task_Hang_MEAASGE;      /* 清除状态 */
 398   2                      Message->MessageAddr = MsgAddr; /* 写入消息地址 */
 399   2                      Message->MessageSize = Size;    /* 写入消息大小 */
 400   2                      OS_TaskSwitch();                                /* 任务切换 */
 401   2              }
 402   1      #else
                      Message = Message;
                      MsgAddr = MsgAddr;
C51 COMPILER V9.00   OS                                                                    05/12/2015 20:18:27 PAGE 8   

                      Size = Size;
              #endif
 407   1      }
 408          
 409          /*
 410           * 发送消息。Message（消息结构体地址）Size（消息大小）
 411           * MsgAddr（消息地址）(ISR)
 412           */
 413          void OS_SendMessage_INT (OS_MSG * Message, OS_CPU_XP_VOID MsgAddr, OS_CPU_CHAR Size) reentrant
 414          {
 415   1      #if OS_Message_ENABLE
 416   1              if(OS_TaskStatus[Message->PendTaskNum] & Task_Hang_MEAASGE)             /* 确定是否在等 */
 417   1              {
 418   2                      /* 等待者就续 */
 419   2                      AddToReadyList(Message->PendTaskNum);
 420   2                      OS_TaskStatus[Message->PendTaskNum] &= ~Task_Hang_MEAASGE;      /* 清除状态 */
 421   2                      Message->MessageAddr = MsgAddr; /* 写入消息地址 */
 422   2                      Message->MessageSize = Size;    /* 写入消息大小 */
 423   2              }
 424   1      #else
                      Message = Message;
                      MsgAddr = MsgAddr;
                      Size = Size;
              #endif
 429   1      }
 430          
 431          /*
 432           =========================================================================================================
             -==============
 433              占用互斥体，如果互斥体已经被占用，则等待(
 434              Mutex:互斥体地址)
 435           =========================================================================================================
             -==============
 436           */
 437          void OS_OccupyMutex(OS_MUTEX *Mutex)reentrant
 438          {
 439   1      #if OS_Mutex_ENABLE
 440   1              OS_MUTEX * Temp = Mutex;
 441   1              if(Mutex->IsOccupy == 0x00)                                     /* 未被占用 */
 442   1              {
 443   2                      Mutex->IsOccupy = OS_CurTaskNum + 1;
 444   2              }
 445   1      
 446   1              if(Mutex->IsOccupy != OS_CurTaskNum + 1)        /* 如果任务已经被占用 */
 447   1              {
 448   2                      DISABLE_ALL_INT();
 449   2                      DeleteFromReadyList(OS_CurTaskNum);             /* 删除就续表 */
 450   2                      OS_TaskStatus[OS_CurTaskNum] |= Task_Hang_MUTEX;        /* 状态等待MUTEX */
 451   2                      AddToMutexList(OS_CurTaskNum, Mutex);                           /* 加入到MUTEX等待表 */
 452   2                      OS_TaskSwitch();                                                /* 任务切换 */
 453   2                      Mutex = Temp;
 454   2                      ENABLE_ALL_INT();
 455   2                      Mutex->IsOccupy = OS_CurTaskNum + 1;    /* 占有成功 */
 456   2              }
 457   1              else
 458   1              {
 459   2                      Mutex->IsOccupy = OS_CurTaskNum + 1;    /* 占有成功 */
 460   2              }
 461   1      
 462   1      #else
                      Mutex = Mutex;
              #endif
C51 COMPILER V9.00   OS                                                                    05/12/2015 20:18:27 PAGE 9   

 465   1      }
 466          
 467          /*
 468           =========================================================================================================
             -==============
 469              释放互斥体，同时切换任务（Mutex：互斥体地址）
 470           =========================================================================================================
             -==============
 471           */
 472          void OS_ReleaseMutex(OS_MUTEX *Mutex)reentrant
 473          {
 474   1              /*~~~~~~~~~~~~~~~~~~~~~~~~~*/
 475   1      #if OS_Mutex_ENABLE
 476   1              OS_CPU_UCHAR    i = 0, j = 0;
 477   1              /*~~~~~~~~~~~~~~~~~~~~~~~~~*/
 478   1      
 479   1              Mutex->IsOccupy = 0x00;                                 /* 未被占用 */
 480   1      
 481   1              for(i = 0; i < OS_MAX_NUM_TASK; i++)    /* 遍历等待列表 */
 482   1              {
 483   2                      if(Mutex->PendList[i / 8] != 0x00)
 484   2                      {
 485   3                              if(Mutex->PendList[i / 8] & (1 << (i % 8)))             /* 寻找等待任务 */
 486   3                              {
 487   4                                      DISABLE_ALL_INT();
 488   4                                      OS_TaskStatus[i] &= ~Task_Hang_MUTEX;           /* 清除等待MUTEX状态 */
 489   4                                      DeleteFromMutexList(i, Mutex);                          /* 从MUTEX等待列表删除 */
 490   4                                      AddToReadyList(i);
 491   4                                      OS_TaskReadyList[i / 8] |= (1 << (i % 8));      /* 加入就续表 */
 492   4                                      OS_TaskSwitch();        /* 任务切换 */
 493   4                                      ENABLE_ALL_INT();
 494   4                              }
 495   3                      }
 496   2              }
 497   1      
 498   1      #else
                      Mutex = Mutex;
              #endif
 501   1      }
 502          
 503          /*
 504           =========================================================================================================
             -==============
 505              释放互斥体，同时切换任务(ISR)（Mutex：互斥体地址）
 506           =========================================================================================================
             -==============
 507           */
 508          void OS_ReleaseMutex_INT(OS_MUTEX *Mutex)reentrant
 509          {
 510   1              /*~~~~~~~~~~~~~~~~~~~~~~~~~*/
 511   1      #if OS_Mutex_ENABLE
 512   1              OS_CPU_UCHAR    i = 0, j = 0;
 513   1              /*~~~~~~~~~~~~~~~~~~~~~~~~~*/
 514   1      
 515   1              Mutex->IsOccupy = 0x00;                                 /* 未被占用 */
 516   1      
 517   1              for(i = 0; i < OS_MAX_NUM_TASK; i++)    /* 遍历等待列表 */
 518   1              {
 519   2                      if(Mutex->PendList[i / 8] != 0x00)
 520   2                      {
 521   3                              if(Mutex->PendList[i / 8] & (1 << (i % 8)))             /* 寻找等待任务 */
 522   3                              {
C51 COMPILER V9.00   OS                                                                    05/12/2015 20:18:27 PAGE 10  

 523   4                                      DISABLE_ALL_INT();
 524   4                                      OS_TaskStatus[i] &= ~Task_Hang_MUTEX;           /* 清除等待MUTEX状态 */
 525   4                                      DeleteFromMutexList(i, Mutex);                          /* 从MUTEX等待列表删除 */
 526   4                                      AddToReadyList(i);
 527   4                                      OS_TaskReadyList[i / 8] |= (1 << (i % 8));      /* 加入就续表 */
 528   4                                      ENABLE_ALL_INT();
 529   4                              }
 530   3                      }
 531   2              }
 532   1      
 533   1      #else
                      Mutex = Mutex;
              #endif
 536   1      }
 537          
 538          /*
 539           =========================================================================================================
             -==============
 540              为防止编译器警告
 541           =========================================================================================================
             -==============
 542           */
 543          void PreventWarning(OS_CPU_UCHAR Nothing)
 544          {
 545   1              if(Nothing)
 546   1              {
 547   2                      OS_PendMessage(OS_CPU_NULL);
 548   2                      OS_SendMessage(OS_CPU_NULL, OS_CPU_NULL, OS_CPU_NULL);
 549   2                      OS_SendMessage_INT(OS_CPU_NULL, OS_CPU_NULL, OS_CPU_NULL);
 550   2                      OS_OccupyMutex(OS_CPU_NULL);
 551   2                      OS_ReleaseMutex(OS_CPU_NULL);
 552   2                      OS_ReleaseMutex_INT(OS_CPU_NULL);
 553   2                      OS_Init();
 554   2                      TickTask();
 555   2                      OS_Delay_nTick(0);
 556   2                      OS_Start();
 557   2                      OS_SysTickInit();
 558   2                      OS_TaskSwitchManual();
 559   2                      OS_SendSignal(0);
 560   2                      OS_PendSignal();
 561   2                      OS_SendSignal_INT(OS_CPU_NULL);
 562   2                      TaskSuspend(0);
 563   2                      TaskResume(0);
 564   2                      TickTask_HOOK();
 565   2                      TaskCreate_HOOK();
 566   2                      TaskSwitch_HOOK();
 567   2                      StackCheckWarning(OS_CPU_NULL, OS_CPU_NULL);
 568   2                      OS_StateTask();
 569   2                      OS_SYS_Task();
 570   2                      OS_TMR_Task();
 571   2                      OS_TIMER_ADD(OS_CPU_NULL, OS_CPU_NULL, OS_CPU_NULL, OS_CPU_NULL);
 572   2              }
 573   1      }
 574          
 575          /*
 576           =========================================================================================================
             -==============
 577              空闲任务
 578           =========================================================================================================
             -==============
 579           */
 580          void TaskIdle(void)
C51 COMPILER V9.00   OS                                                                    05/12/2015 20:18:27 PAGE 11  

 581          {
 582   1              /*~~~~~~~~~~~~~~~~~~~~~~~~~*/
 583   1              OS_CPU_XUCHAR   i = 0;
 584   1              /*~~~~~~~~~~~~~~~~~~~~~~~~~*/
 585   1      
 586   1              while(1)
 587   1              {
 588   2                      for(i = 0; i < 240; i++)
 589   2                      {
 590   3                              ;
 591   3                      }
 592   2              }
 593   1      }
 594          
 595          /*
 596           =========================================================================================================
             -==============
 597              任务恢复(Prio:欲恢复任务的优先级号)
 598           =========================================================================================================
             -==============
 599           */
 600          void TaskResume(OS_CPU_UCHAR Prio)
 601          {
 602   1              DISABLE_ALL_INT();
 603   1              AddToReadyList(Prio);
 604   1              OS_TaskSwitch();
 605   1              ENABLE_ALL_INT();
 606   1      }
 607          
 608          /*
 609           =========================================================================================================
             -==============
 610              任务暂停(Prio:欲暂停任务的优先级号)
 611           =========================================================================================================
             -==============
 612           */
 613          void TaskSuspend(OS_CPU_UCHAR Prio)
 614          {
 615   1              DISABLE_ALL_INT();
 616   1              DeleteFromReadyList(Prio);
 617   1              OS_TaskSwitch();
 618   1              ENABLE_ALL_INT();
 619   1      }
 620          
 621          /*
 622           =========================================================================================================
             -==============
 623              统计任务（每OS_State_Period个滴答执行一次），当任务过于简单时，统计任务几乎失效
 624           =========================================================================================================
             -==============
 625           */
 626          void OS_StateTask(void)
 627          {
 628   1              /*~~~~~~~~~~~~~~~~~~*/
 629   1      #if OS_State_ENABLE
 630   1              OS_CPU_UCHAR    i = 0;
 631   1              /*~~~~~~~~~~~~~~~~~~*/
 632   1      
 633   1              for(i = 0; i < OS_MAX_NUM_TASK; i++)
 634   1              {
 635   2                      /* 任务的CPU占有率 */
 636   2                      CPU_Usage[i] = CPU_Usage_Counter[i] * StateRate * 1.0 / OS_State_Period;
C51 COMPILER V9.00   OS                                                                    05/12/2015 20:18:27 PAGE 12  

 637   2                      CPU_Usage_Counter[i] = 0;
 638   2              }
 639   1      
 640   1              CPU_Usage_ALL = StateRate - CPU_Usage[OS_MAX_NUM_TASK - 1]; /* CPU使用率 */
 641   1      #else
              #endif
 643   1      }
 644          
 645          /*
 646           =========================================================================================================
             -==============
 647              操作系统任务(定时器和统计任务通过Message触发)
 648           =========================================================================================================
             -==============
 649           */
 650          void OS_SYS_Task(void)
 651          {
 652   1              /*~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
 653   1              OS_CPU_UCHAR    Inf = 0, i = 0;
 654   1              OS_CPU_P_XCHAR  pBuff = 0x1234;
 655   1              /*~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
 656   1      
 657   1              while(1)
 658   1              {
 659   2                      OS_PendMessage(&OS_Msg_SYS);
 660   2                      pBuff = OS_Msg_SYS.MessageAddr;
 661   2                      for(i = 0; i < Task_SYS_MsgLength; i++)
 662   2                      {
 663   3                              switch(pBuff[i])
 664   3                              {
 665   4                              case 0:         break;
 666   4                              case 1:         { OS_TMR_Task(); break; }
 667   4                              case 2:         { OS_StateTask(); break; }
 668   4                              case 3:         { OS_StackCheck_Task(); break; }
 669   4                              default:        break;
 670   4                              }
 671   3      
 672   3                              pBuff[i] = 0;
 673   3                      }
 674   2              }
 675   1      }
 676          
 677          /*
 678           =========================================================================================================
             -==============
 679              定时器任务
 680           =========================================================================================================
             -==============
 681           */
 682          void OS_TMR_Task(void)
 683          {
 684   1              /*~~~~~~~~~~~~~~~~~~*/
 685   1      #if OS_TIMER_ENABLE
 686   1              OS_CPU_UCHAR    i = 0;
 687   1              /*~~~~~~~~~~~~~~~~~~*/
 688   1      
 689   1              for(i = 0; i < OS_TIMER_MAX_NUM; i++)
 690   1              {
 691   2                      if(OS_TIMER_ARRAY[i] == OS_TIMER_Counter)
 692   2                      {
 693   3                              if((OS_X_Tmr.State[i] & OS_TIMER_STATE_Actived) != 0x00)        /* 确保已激活 */
 694   3                              {
C51 COMPILER V9.00   OS                                                                    05/12/2015 20:18:27 PAGE 13  

 695   4                                      if(OS_X_Tmr.TimerType[i] == OS_TIMER_TYPE_nTimes)               /* 多次 */
 696   4                                      {
 697   5                                              if(OS_X_Tmr.TriggerNum[i] > 0)
 698   5                                              {
 699   6                                                      OS_X_Tmr.TriggerNum[i]--;
 700   6                                                      OS_X_Tmr.TimerCallBackFunc[i]();
 701   6                                                      OS_TIMER_ARRAY[i] += OS_X_Tmr.TimerLength[i];
 702   6                                              }
 703   5                                              else
 704   5                                              {
 705   6                                                      OS_X_Tmr.State[i] &= ~OS_TIMER_STATE_Actived;
 706   6                                              }
 707   5                                      }
 708   4      
 709   4                                      if(OS_X_Tmr.TimerType[i] == OS_TIMER_TYPE_PERIOD)               /* 周期型 */
 710   4                                      {
 711   5                                              OS_X_Tmr.TimerCallBackFunc[i]();
 712   5                                              OS_TIMER_ARRAY[i] += OS_X_Tmr.TimerLength[i];
 713   5                                      }
 714   4                              }
 715   3                      }
 716   2              }
 717   1      #endif
 718   1      }
 719          
 720          /*
 721           =========================================================================================================
             -==============
 722              添加定时器(会以最高优先级运行)(TaskName:任务名称
 723              TimerLength:定时长度 TimerType:定时器类型 TriggerNum:执行次数)
 724           =========================================================================================================
             -==============
 725           */
 726          void OS_TIMER_ADD(OS_CPU_INT TaskName, OS_CPU_INT TimerLength, OS_CPU_CHAR TimerType, OS_CPU_UCHAR Trigger
             -Num)
 727          {
 728   1              /*~~~~~~~~~~~~~~~~~~*/
 729   1      #if OS_TIMER_ENABLE
 730   1              OS_CPU_UCHAR    i = 0;
 731   1              /*~~~~~~~~~~~~~~~~~~*/
 732   1      
 733   1              for(i = 0; i < OS_TIMER_MAX_NUM; i++)
 734   1              {
 735   2                      if((OS_X_Tmr.State[i] & OS_TIMER_STATE_Actived) == 0x00)                /* 寻找未激活任务 */
 736   2                      {
 737   3                              DISABLE_ALL_INT();
 738   3                              OS_X_Tmr.TimerCallBackFunc[i] = (OS_CPU_P_VOID) TaskName;       /* 任务名称 */
 739   3                              OS_X_Tmr.TimerLength[i] = TimerLength;                                          /* 定时长度 */
 740   3                              OS_X_Tmr.TimerType[i] = TimerType;                              /* 定时器类型 */
 741   3                              OS_X_Tmr.TriggerNum[i] = TriggerNum;                    /* 触发次数 */
 742   3                              OS_TIMER_ARRAY[i] += TimerLength;
 743   3                              OS_X_Tmr.State[i] |= OS_TIMER_STATE_Actived;    /* 定时器激活 */
 744   3                              ENABLE_ALL_INT();
 745   3                              break;
 746   3                      }
 747   2              }
 748   1      
 749   1              if(i == OS_TIMER_MAX_NUM)
 750   1              {
 751   2                      while(1) DISABLE_ALL_INT();
 752   2              }
 753   1      
C51 COMPILER V9.00   OS                                                                    05/12/2015 20:18:27 PAGE 14  

 754   1      #else
                      TaskName = TaskName;
                      TimerLength = TimerLength;
                      TimerType = TimerType;
                      TriggerNum = TriggerNum;
              #endif
 760   1      }
 761          
 762          /*
 763           =========================================================================================================
             -==============
 764              堆栈安全检查
 765           =========================================================================================================
             -==============
 766           */
 767          void OS_StackCheck_Task(void)
 768          {
 769   1              /*~~~~~~~~~~~~~~~~~~*/
 770   1              OS_CPU_UCHAR    i = 0;
 771   1              /*~~~~~~~~~~~~~~~~~~*/
 772   1      
 773   1              for(i = 0; i < OS_MAX_NUM_TASK; i++)
 774   1              {
 775   2                      if(OS_TaskCurLength[i] >= (OS_TaskStackSize[i] - OS_StackSafeSurplus))
 776   2                      {
 777   3      #if OS_HOOK_ENABLE
 778   3                              StackCheckWarning(i, (OS_TaskStackSize[i] - OS_TaskCurLength[i]));
 779   3      #endif
 780   3                      }
 781   2              }
 782   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3469    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    202      10
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     37      24
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
